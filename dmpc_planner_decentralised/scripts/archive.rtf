def set_initial_x_plan_1(self, xinit):
        # x = x y theta vx vy w s
        #     2 3   4   5  6  7 8

        # assign initial guess for the states by forward euler integration on the reference path
        # refinement for first guess needs to be higher because the forward euler is a bit lame
        N_0 = 1000

        s_0_vec = np.linspace(0, 0 + self.reference_velocity * 1.5, N_0+1)
        x_ref_0 = np.ones(N_0+1) * xinit[0]
        y_ref_0 = np.ones(N_0+1) * xinit[1]
        theta_ref_0 = np.ones(N_0+1) * xinit[2]

        for i in range(1,N_0+1):
            x_ref_0[i] = x_ref_0[i-1] + self.reference_velocity * self._dt * np.cos(theta_ref_0[i-1])
            y_ref_0[i] = y_ref_0[i-1] + self.reference_velocity * self._dt * np.sin(theta_ref_0[i-1])
            # theta_ref_0[i] = theta_ref_0[i-1] + k_0_vals[i-1] * self.reference_velocity * self._dt
        
        # now down sample to the N points
        self._mpc_x_plan[0,:] = np.interp(np.linspace(0,1,self._N), np.linspace(0,1,N_0+1), x_ref_0)
        self._mpc_x_plan[1,:] = np.interp(np.linspace(0,1,self._N), np.linspace(0,1,N_0+1), y_ref_0)
        self._mpc_x_plan[3,:] = self.reference_velocity
        self._mpc_x_plan[6,:] = np.interp(np.linspace(0,1,self._N), np.linspace(0,1,N_0+1), s_0_vec) 
        
    def set_initial_x_plan_2(self, xinit):
        # x = x y theta vx vy w s
        #     2 3   4   5  6  7 8

        # assign initial guess for the states by forward euler integration on the reference path
        # refinement for first guess needs to be higher because the forward euler is a bit lame
        N_0 = 1000

        s_0_vec = np.linspace(0, 0 + self.reference_velocity * 1.5, N_0+1)
        x_ref_0 = np.ones(N_0+1) * xinit[0 + self._nx_one_robot]
        y_ref_0 = np.ones(N_0+1) * xinit[1 + self._nx_one_robot]
        theta_ref_0 = np.ones(N_0+1) * xinit[2 + self._nx_one_robot]

        for i in range(1,N_0+1):
            x_ref_0[i] = x_ref_0[i-1] + self.reference_velocity * self._dt * np.cos(theta_ref_0[i-1])
            y_ref_0[i] = y_ref_0[i-1] + self.reference_velocity * self._dt * np.sin(theta_ref_0[i-1])
            # theta_ref_0[i] = theta_ref_0[i-1] + k_0_vals[i-1] * self.reference_velocity * self._dt
        
        # now down sample to the N points
        self._mpc_x_plan[0 + self._nx_one_robot,:] = np.interp(np.linspace(0,1,self._N), np.linspace(0,1,N_0+1), x_ref_0)
        self._mpc_x_plan[1 + self._nx_one_robot,:] = np.interp(np.linspace(0,1,self._N), np.linspace(0,1,N_0+1), y_ref_0)
        self._mpc_x_plan[3 + self._nx_one_robot,:] = self.reference_velocity
        self._mpc_x_plan[6 + self._nx_one_robot,:] = np.interp(np.linspace(0,1,self._N), np.linspace(0,1,N_0+1), s_0_vec)

    def set_projection(self, projection_func):  # # Not adjusted for multi robot
        self._projection_func = projection_func

    def get_braking_trajectory(self, state):    # Not adjusted for multi robot
        x = state[0]
        y = state[1]
        theta = state[2]
        v = state[3]
        spline = state[4]

        result = np.zeros((5, self._N))
        result[:, 0] = np.array([x, y, theta, v, spline])
        for k in range(1, self._N):
            x += v * self._dt * math.cos(theta)
            y += v * self._dt * math.sin(theta)
            spline += v * self._dt
            v -= self._braking_acceleration * self._dt
            v = np.max([v, 0.])
            result[:, k] = np.array([x, y, theta, v, spline])
        return result